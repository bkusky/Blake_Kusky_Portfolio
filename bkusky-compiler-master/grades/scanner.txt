=====STUDENT TESTS=====
====Good Tests====
===[good0.bminor Input]===
// basic types
array auto boolean char else false for function if integer print return string true void while
i x mystr fog123 BigLongName55


===[good0.bminor Output]===
ARRAY
AUTO
BOOL
CHAR
ELSE
FALSE
FOR
FUNCTION
IF
INTEGER
PRINT
RETURN
STRING
TRUE
VOID
WHILE
IDENTIFIER i
IDENTIFIER x
IDENTIFIER mystr
IDENTIFIER fog123
IDENTIFIER BigLongName55




===[good1.bminor Input]===
// Good Comments

// This is a comment
/* this is a comment */

/**/
/***/
/****/

/* adsf
asdf
asdf */



===[good1.bminor Output]===




===[good2.bminor Input]===
// strings

""
mystr: string;
mystr: string = "this is a string"
mystr: string = "this is a string too"
mystr: string = "ttttttttttthhhhhhhiiiiiiiissssssss isssssssss aaaaaaaa sssssttttttrrrrrriiiiinnnnnnggggggg"

"adsfkladsf"
""
""""

===[good2.bminor Output]===
STRING_LITERAL 
IDENTIFIER mystr
COLON
STRING
SEMICOLON
IDENTIFIER mystr
COLON
STRING
ASSIGNMENT
STRING_LITERAL this is a string
IDENTIFIER mystr
COLON
STRING
ASSIGNMENT
STRING_LITERAL this is a string too
IDENTIFIER mystr
COLON
STRING
ASSIGNMENT
STRING_LITERAL ttttttttttthhhhhhhiiiiiiiissssssss isssssssss aaaaaaaa sssssttttttrrrrrriiiiinnnnnnggggggg
STRING_LITERAL adsfkladsf
STRING_LITERAL 
STRING_LITERAL 
STRING_LITERAL 




===[good3.bminor Input]===
// integers
1234
5678
-1234
-5678
+1234
+5678
integer = 12341234;
integer = 56785678;
integer = +12341324;
integer = +56785768;
integer;
01
001
0001
00001
000001
0000001
010
0010
00010
000010
0000010


===[good3.bminor Output]===
INTEGER_LITERAL 1234
INTEGER_LITERAL 5678
INTEGER_LITERAL -1234
INTEGER_LITERAL -5678
INTEGER_LITERAL +1234
INTEGER_LITERAL +5678
INTEGER
ASSIGNMENT
INTEGER_LITERAL 12341234
SEMICOLON
INTEGER
ASSIGNMENT
INTEGER_LITERAL 56785678
SEMICOLON
INTEGER
ASSIGNMENT
INTEGER_LITERAL +12341324
SEMICOLON
INTEGER
ASSIGNMENT
INTEGER_LITERAL +56785768
SEMICOLON
INTEGER
SEMICOLON
INTEGER_LITERAL 01
INTEGER_LITERAL 001
INTEGER_LITERAL 0001
INTEGER_LITERAL 00001
INTEGER_LITERAL 000001
INTEGER_LITERAL 0000001
INTEGER_LITERAL 010
INTEGER_LITERAL 0010
INTEGER_LITERAL 00010
INTEGER_LITERAL 000010
INTEGER_LITERAL 0000010




===[good4.bminor Input]===
// characters

char
char =
char = 'a'

char
char=
char='a'

mychar : char
mychar : char = 'a'
mychar:char='a'

'\n'
'a''\n''a'

===[good4.bminor Output]===
CHAR
CHAR
ASSIGNMENT
CHAR
ASSIGNMENT
CHARACTER_LITERAL a
CHAR
CHAR
ASSIGNMENT
CHAR
ASSIGNMENT
CHARACTER_LITERAL a
IDENTIFIER mychar
COLON
CHAR
IDENTIFIER mychar
COLON
CHAR
ASSIGNMENT
CHARACTER_LITERAL a
IDENTIFIER mychar
COLON
CHAR
ASSIGNMENT
CHARACTER_LITERAL a
CHARACTER_LITERAL 

CHARACTER_LITERAL a
CHARACTER_LITERAL 

CHARACTER_LITERAL a




===[good5.bminor Input]===
printarray: function void ( a: array [] integer, size: integer ) = {
	i: integer;
	for( i=0;i<size;i++) {
		print a[i], "\n";
	}
}

puts: function void ( s: string );

main: function integer () = {
	puts("hello world");
}

main: function integer ( argc: integer, argv: array [] string ) = {
        puts("hello world");
}

===[good5.bminor Output]===
IDENTIFIER printarray
COLON
FUNCTION
VOID
OPEN_PARENTHESIS
IDENTIFIER a
COLON
ARRAY
OPEN_HARD_BRACE
CLOSED_HARD_BRACE
INTEGER
COMMA
IDENTIFIER size
COLON
INTEGER
CLOSED_PARENTHESIS
ASSIGNMENT
OPEN_CURLY_BRACE
IDENTIFIER i
COLON
INTEGER
SEMICOLON
FOR
OPEN_PARENTHESIS
IDENTIFIER i
ASSIGNMENT
INTEGER_LITERAL 0
SEMICOLON
IDENTIFIER i
LESS_THAN
IDENTIFIER size
SEMICOLON
IDENTIFIER i
POSTFIX_INCREMENT
CLOSED_PARENTHESIS
OPEN_CURLY_BRACE
PRINT
IDENTIFIER a
OPEN_HARD_BRACE
IDENTIFIER i
CLOSED_HARD_BRACE
COMMA
STRING_LITERAL 

SEMICOLON
CLOSED_CURLY_BRACE
CLOSED_CURLY_BRACE
IDENTIFIER puts
COLON
FUNCTION
VOID
OPEN_PARENTHESIS
IDENTIFIER s
COLON
STRING
CLOSED_PARENTHESIS
SEMICOLON
IDENTIFIER main
COLON
FUNCTION
INTEGER
OPEN_PARENTHESIS
CLOSED_PARENTHESIS
ASSIGNMENT
OPEN_CURLY_BRACE
IDENTIFIER puts
OPEN_PARENTHESIS
STRING_LITERAL hello world
CLOSED_PARENTHESIS
SEMICOLON
CLOSED_CURLY_BRACE
IDENTIFIER main
COLON
FUNCTION
INTEGER
OPEN_PARENTHESIS
IDENTIFIER argc
COLON
INTEGER
COMMA
IDENTIFIER argv
COLON
ARRAY
OPEN_HARD_BRACE
CLOSED_HARD_BRACE
STRING
CLOSED_PARENTHESIS
ASSIGNMENT
OPEN_CURLY_BRACE
IDENTIFIER puts
OPEN_PARENTHESIS
STRING_LITERAL hello world
CLOSED_PARENTHESIS
SEMICOLON
CLOSED_CURLY_BRACE




===[good6.bminor Input]===
myarray:array [6] integer = {1,1,1,1,1,1}
myarray:array [6] integer = {1, 1, 1, 1, 1, 1}
myarray : array [ 6 ] integer = {1, 1, 1, 1, 1, 1}
myarray:array[6]integer={1,1,1,1,1,1}

myarray:array [1]  char = {'a'}

myarray:array [2] string = {"hello", "world")

myarray:array [3] boolean = {true, true, false}


===[good6.bminor Output]===
IDENTIFIER myarray
COLON
ARRAY
OPEN_HARD_BRACE
INTEGER_LITERAL 6
CLOSED_HARD_BRACE
INTEGER
ASSIGNMENT
OPEN_CURLY_BRACE
INTEGER_LITERAL 1
COMMA
INTEGER_LITERAL 1
COMMA
INTEGER_LITERAL 1
COMMA
INTEGER_LITERAL 1
COMMA
INTEGER_LITERAL 1
COMMA
INTEGER_LITERAL 1
CLOSED_CURLY_BRACE
IDENTIFIER myarray
COLON
ARRAY
OPEN_HARD_BRACE
INTEGER_LITERAL 6
CLOSED_HARD_BRACE
INTEGER
ASSIGNMENT
OPEN_CURLY_BRACE
INTEGER_LITERAL 1
COMMA
INTEGER_LITERAL 1
COMMA
INTEGER_LITERAL 1
COMMA
INTEGER_LITERAL 1
COMMA
INTEGER_LITERAL 1
COMMA
INTEGER_LITERAL 1
CLOSED_CURLY_BRACE
IDENTIFIER myarray
COLON
ARRAY
OPEN_HARD_BRACE
INTEGER_LITERAL 6
CLOSED_HARD_BRACE
INTEGER
ASSIGNMENT
OPEN_CURLY_BRACE
INTEGER_LITERAL 1
COMMA
INTEGER_LITERAL 1
COMMA
INTEGER_LITERAL 1
COMMA
INTEGER_LITERAL 1
COMMA
INTEGER_LITERAL 1
COMMA
INTEGER_LITERAL 1
CLOSED_CURLY_BRACE
IDENTIFIER myarray
COLON
ARRAY
OPEN_HARD_BRACE
INTEGER_LITERAL 6
CLOSED_HARD_BRACE
INTEGER
ASSIGNMENT
OPEN_CURLY_BRACE
INTEGER_LITERAL 1
COMMA
INTEGER_LITERAL 1
COMMA
INTEGER_LITERAL 1
COMMA
INTEGER_LITERAL 1
COMMA
INTEGER_LITERAL 1
COMMA
INTEGER_LITERAL 1
CLOSED_CURLY_BRACE
IDENTIFIER myarray
COLON
ARRAY
OPEN_HARD_BRACE
INTEGER_LITERAL 1
CLOSED_HARD_BRACE
CHAR
ASSIGNMENT
OPEN_CURLY_BRACE
CHARACTER_LITERAL a
CLOSED_CURLY_BRACE
IDENTIFIER myarray
COLON
ARRAY
OPEN_HARD_BRACE
INTEGER_LITERAL 2
CLOSED_HARD_BRACE
STRING
ASSIGNMENT
OPEN_CURLY_BRACE
STRING_LITERAL hello
COMMA
STRING_LITERAL world
CLOSED_PARENTHESIS
IDENTIFIER myarray
COLON
ARRAY
OPEN_HARD_BRACE
INTEGER_LITERAL 3
CLOSED_HARD_BRACE
BOOL
ASSIGNMENT
OPEN_CURLY_BRACE
TRUE
COMMA
TRUE
COMMA
FALSE
CLOSED_CURLY_BRACE




===[good7.bminor Input]===
// comparisons and if
if ( a == b ) {
	if ( b != c ) {
		if ( c < d ) {
			if ( d <= e ) {
				if ( e > f ) {
					g = f && e
					h = d || a
				} else if ( g == h ) {
					q = h || g && b
				} else {
					return
				}
			}
		}	
	}
}

===[good7.bminor Output]===
IF
OPEN_PARENTHESIS
IDENTIFIER a
EQUAL
IDENTIFIER b
CLOSED_PARENTHESIS
OPEN_CURLY_BRACE
IF
OPEN_PARENTHESIS
IDENTIFIER b
TOKEN_NEQ
IDENTIFIER c
CLOSED_PARENTHESIS
OPEN_CURLY_BRACE
IF
OPEN_PARENTHESIS
IDENTIFIER c
LESS_THAN
IDENTIFIER d
CLOSED_PARENTHESIS
OPEN_CURLY_BRACE
IF
OPEN_PARENTHESIS
IDENTIFIER d
LESS_THEN_OR_EQUAL_TO
IDENTIFIER e
CLOSED_PARENTHESIS
OPEN_CURLY_BRACE
IF
OPEN_PARENTHESIS
IDENTIFIER e
GREATER_THAN
IDENTIFIER f
CLOSED_PARENTHESIS
OPEN_CURLY_BRACE
IDENTIFIER g
ASSIGNMENT
IDENTIFIER f
AND
IDENTIFIER e
IDENTIFIER h
ASSIGNMENT
IDENTIFIER d
OR
IDENTIFIER a
CLOSED_CURLY_BRACE
ELSE
IF
OPEN_PARENTHESIS
IDENTIFIER g
EQUAL
IDENTIFIER h
CLOSED_PARENTHESIS
OPEN_CURLY_BRACE
IDENTIFIER q
ASSIGNMENT
IDENTIFIER h
OR
IDENTIFIER g
AND
IDENTIFIER b
CLOSED_CURLY_BRACE
ELSE
OPEN_CURLY_BRACE
RETURN
CLOSED_CURLY_BRACE
CLOSED_CURLY_BRACE
CLOSED_CURLY_BRACE
CLOSED_CURLY_BRACE
CLOSED_CURLY_BRACE




===[good8.bminor Input]===
// as much bminor as I can find

printarray: function void ( a: array [] integer, size: integer ) = {
	i: integer;
	for( i=0;i<size;i++) {
		print a[i], "\n";
	}
}

puts: function void ( s: string );

main: function integer () = {
	puts("hello world");
}

main: function integer ( argc: integer, argv: array [] string ) = {
        puts("hello world");
}


/* A C-style comment */
a=5; // A C++ style comment

x: integer;
y: integer = 123;
b: boolean = false;
c: char    = 'q';
s: string  = "hello bminor\n";

a: array [5] integer;

a: array [5] integer = {1,2,3,4,5};

a: auto = 10;
b: auto = "hello";
c: auto = a < 100;

b: boolean;
x: integer = 3;
y: integer = 5;
b = x<y;     // ok: the expression x<y is boolean

f: integer = 0;
if(f==0)    // ok: f==0 is a boolean expression

c: char = 'a';
if(c=='a') // ok: c and 'a' are both chars

// An arithmetic expression statement.
y = m*x + b;

// A return statement.
return (f-32)*5/9;

// An if-else statement.
if( temp>100 ) {
    print "It's really hot!\n";
} else if( temp>70 ) {
    print "It's pretty warm.\n";
} else {
    print "It's not too bad.\n";
}

// A for loop statement.
for( i=0; i<100; i++ ) {
    print i;0
}

print "The temperature is: ", temp, " degrees\n";

square: function integer ( x: integer ) = {
	return x^2;
}

printarray: function void ( a: array [] integer, size: integer ) = {
	i: integer;
	for( i=0;i<size;i++) {
		print a[i], "\n";
	}
}

puts: function void ( s: string );

main: function integer () = {
	puts("hello world");
}

main: function integer ( argc: integer, argv: array [] string ) = {
        puts("hello world");
}

===[good8.bminor Output]===
IDENTIFIER printarray
COLON
FUNCTION
VOID
OPEN_PARENTHESIS
IDENTIFIER a
COLON
ARRAY
OPEN_HARD_BRACE
CLOSED_HARD_BRACE
INTEGER
COMMA
IDENTIFIER size
COLON
INTEGER
CLOSED_PARENTHESIS
ASSIGNMENT
OPEN_CURLY_BRACE
IDENTIFIER i
COLON
INTEGER
SEMICOLON
FOR
OPEN_PARENTHESIS
IDENTIFIER i
ASSIGNMENT
INTEGER_LITERAL 0
SEMICOLON
IDENTIFIER i
LESS_THAN
IDENTIFIER size
SEMICOLON
IDENTIFIER i
POSTFIX_INCREMENT
CLOSED_PARENTHESIS
OPEN_CURLY_BRACE
PRINT
IDENTIFIER a
OPEN_HARD_BRACE
IDENTIFIER i
CLOSED_HARD_BRACE
COMMA
STRING_LITERAL 

SEMICOLON
CLOSED_CURLY_BRACE
CLOSED_CURLY_BRACE
IDENTIFIER puts
COLON
FUNCTION
VOID
OPEN_PARENTHESIS
IDENTIFIER s
COLON
STRING
CLOSED_PARENTHESIS
SEMICOLON
IDENTIFIER main
COLON
FUNCTION
INTEGER
OPEN_PARENTHESIS
CLOSED_PARENTHESIS
ASSIGNMENT
OPEN_CURLY_BRACE
IDENTIFIER puts
OPEN_PARENTHESIS
STRING_LITERAL hello world
CLOSED_PARENTHESIS
SEMICOLON
CLOSED_CURLY_BRACE
IDENTIFIER main
COLON
FUNCTION
INTEGER
OPEN_PARENTHESIS
IDENTIFIER argc
COLON
INTEGER
COMMA
IDENTIFIER argv
COLON
ARRAY
OPEN_HARD_BRACE
CLOSED_HARD_BRACE
STRING
CLOSED_PARENTHESIS
ASSIGNMENT
OPEN_CURLY_BRACE
IDENTIFIER puts
OPEN_PARENTHESIS
STRING_LITERAL hello world
CLOSED_PARENTHESIS
SEMICOLON
CLOSED_CURLY_BRACE
IDENTIFIER a
ASSIGNMENT
INTEGER_LITERAL 5
SEMICOLON
IDENTIFIER x
COLON
INTEGER
SEMICOLON
IDENTIFIER y
COLON
INTEGER
ASSIGNMENT
INTEGER_LITERAL 123
SEMICOLON
IDENTIFIER b
COLON
BOOL
ASSIGNMENT
FALSE
SEMICOLON
IDENTIFIER c
COLON
CHAR
ASSIGNMENT
CHARACTER_LITERAL q
SEMICOLON
IDENTIFIER s
COLON
STRING
ASSIGNMENT
STRING_LITERAL hello bminor

SEMICOLON
IDENTIFIER a
COLON
ARRAY
OPEN_HARD_BRACE
INTEGER_LITERAL 5
CLOSED_HARD_BRACE
INTEGER
SEMICOLON
IDENTIFIER a
COLON
ARRAY
OPEN_HARD_BRACE
INTEGER_LITERAL 5
CLOSED_HARD_BRACE
INTEGER
ASSIGNMENT
OPEN_CURLY_BRACE
INTEGER_LITERAL 1
COMMA
INTEGER_LITERAL 2
COMMA
INTEGER_LITERAL 3
COMMA
INTEGER_LITERAL 4
COMMA
INTEGER_LITERAL 5
CLOSED_CURLY_BRACE
SEMICOLON
IDENTIFIER a
COLON
AUTO
ASSIGNMENT
INTEGER_LITERAL 10
SEMICOLON
IDENTIFIER b
COLON
AUTO
ASSIGNMENT
STRING_LITERAL hello
SEMICOLON
IDENTIFIER c
COLON
AUTO
ASSIGNMENT
IDENTIFIER a
LESS_THAN
INTEGER_LITERAL 100
SEMICOLON
IDENTIFIER b
COLON
BOOL
SEMICOLON
IDENTIFIER x
COLON
INTEGER
ASSIGNMENT
INTEGER_LITERAL 3
SEMICOLON
IDENTIFIER y
COLON
INTEGER
ASSIGNMENT
INTEGER_LITERAL 5
SEMICOLON
IDENTIFIER b
ASSIGNMENT
IDENTIFIER x
LESS_THAN
IDENTIFIER y
SEMICOLON
IDENTIFIER f
COLON
INTEGER
ASSIGNMENT
INTEGER_LITERAL 0
SEMICOLON
IF
OPEN_PARENTHESIS
IDENTIFIER f
EQUAL
INTEGER_LITERAL 0
CLOSED_PARENTHESIS
IDENTIFIER c
COLON
CHAR
ASSIGNMENT
CHARACTER_LITERAL a
SEMICOLON
IF
OPEN_PARENTHESIS
IDENTIFIER c
EQUAL
CHARACTER_LITERAL a
CLOSED_PARENTHESIS
IDENTIFIER y
ASSIGNMENT
IDENTIFIER m
MULTIPLY
IDENTIFIER x
ADD
IDENTIFIER b
SEMICOLON
RETURN
OPEN_PARENTHESIS
IDENTIFIER f
INTEGER_LITERAL -32
CLOSED_PARENTHESIS
MULTIPLY
INTEGER_LITERAL 5
DIVIDE
INTEGER_LITERAL 9
SEMICOLON
IF
OPEN_PARENTHESIS
IDENTIFIER temp
GREATER_THAN
INTEGER_LITERAL 100
CLOSED_PARENTHESIS
OPEN_CURLY_BRACE
PRINT
STRING_LITERAL It's really hot!

SEMICOLON
CLOSED_CURLY_BRACE
ELSE
IF
OPEN_PARENTHESIS
IDENTIFIER temp
GREATER_THAN
INTEGER_LITERAL 70
CLOSED_PARENTHESIS
OPEN_CURLY_BRACE
PRINT
STRING_LITERAL It's pretty warm.

SEMICOLON
CLOSED_CURLY_BRACE
ELSE
OPEN_CURLY_BRACE
PRINT
STRING_LITERAL It's not too bad.

SEMICOLON
CLOSED_CURLY_BRACE
FOR
OPEN_PARENTHESIS
IDENTIFIER i
ASSIGNMENT
INTEGER_LITERAL 0
SEMICOLON
IDENTIFIER i
LESS_THAN
INTEGER_LITERAL 100
SEMICOLON
IDENTIFIER i
POSTFIX_INCREMENT
CLOSED_PARENTHESIS
OPEN_CURLY_BRACE
PRINT
IDENTIFIER i
SEMICOLON
INTEGER_LITERAL 0
CLOSED_CURLY_BRACE
PRINT
STRING_LITERAL The temperature is: 
COMMA
IDENTIFIER temp
COMMA
STRING_LITERAL  degrees

SEMICOLON
IDENTIFIER square
COLON
FUNCTION
INTEGER
OPEN_PARENTHESIS
IDENTIFIER x
COLON
INTEGER
CLOSED_PARENTHESIS
ASSIGNMENT
OPEN_CURLY_BRACE
RETURN
IDENTIFIER x
EXPONENT
INTEGER_LITERAL 2
SEMICOLON
CLOSED_CURLY_BRACE
IDENTIFIER printarray
COLON
FUNCTION
VOID
OPEN_PARENTHESIS
IDENTIFIER a
COLON
ARRAY
OPEN_HARD_BRACE
CLOSED_HARD_BRACE
INTEGER
COMMA
IDENTIFIER size
COLON
INTEGER
CLOSED_PARENTHESIS
ASSIGNMENT
OPEN_CURLY_BRACE
IDENTIFIER i
COLON
INTEGER
SEMICOLON
FOR
OPEN_PARENTHESIS
IDENTIFIER i
ASSIGNMENT
INTEGER_LITERAL 0
SEMICOLON
IDENTIFIER i
LESS_THAN
IDENTIFIER size
SEMICOLON
IDENTIFIER i
POSTFIX_INCREMENT
CLOSED_PARENTHESIS
OPEN_CURLY_BRACE
PRINT
IDENTIFIER a
OPEN_HARD_BRACE
IDENTIFIER i
CLOSED_HARD_BRACE
COMMA
STRING_LITERAL 

SEMICOLON
CLOSED_CURLY_BRACE
CLOSED_CURLY_BRACE
IDENTIFIER puts
COLON
FUNCTION
VOID
OPEN_PARENTHESIS
IDENTIFIER s
COLON
STRING
CLOSED_PARENTHESIS
SEMICOLON
IDENTIFIER main
COLON
FUNCTION
INTEGER
OPEN_PARENTHESIS
CLOSED_PARENTHESIS
ASSIGNMENT
OPEN_CURLY_BRACE
IDENTIFIER puts
OPEN_PARENTHESIS
STRING_LITERAL hello world
CLOSED_PARENTHESIS
SEMICOLON
CLOSED_CURLY_BRACE
IDENTIFIER main
COLON
FUNCTION
INTEGER
OPEN_PARENTHESIS
IDENTIFIER argc
COLON
INTEGER
COMMA
IDENTIFIER argv
COLON
ARRAY
OPEN_HARD_BRACE
CLOSED_HARD_BRACE
STRING
CLOSED_PARENTHESIS
ASSIGNMENT
OPEN_CURLY_BRACE
IDENTIFIER puts
OPEN_PARENTHESIS
STRING_LITERAL hello world
CLOSED_PARENTHESIS
SEMICOLON
CLOSED_CURLY_BRACE




===[good9.bminor Input]===
// some edge cases

"still a str\n still a str"
"anything in a string goes !@#$%^&*()_+-="

_ident_name
ident7ident


" "
"    "
/* "  string in comment " */
" /* comment in string */ "
// " string in comment "
" // comment in string "

/* the ternary */
:
?



===[good9.bminor Output]===
STRING_LITERAL still a str
 still a str
STRING_LITERAL anything in a string goes !@#$%^&*()_+-=
IDENTIFIER _ident_name
IDENTIFIER ident7ident
STRING_LITERAL  
STRING_LITERAL     
STRING_LITERAL  /* comment in string */  !
STRING_LITERAL  // comment in string 
COLON
QUESTION_MARK




====Bad Tests====
===[bad0.bminor Input]===
// bad string 

" multiline
string "

===[bad0.bminor Output]===
ERROR




===[bad1.bminor Input]===
// character issue

printarray: function void ( a: array [] integer, size: integer ) = {
	i: integer;
	for( i=0;i<size;i++) {
		print(a[i]), &"\n";
	}
}

===[bad1.bminor Output]===
IDENTIFIER printarray
COLON
FUNCTION
VOID
OPEN_PARENTHESIS
IDENTIFIER a
COLON
ARRAY
OPEN_HARD_BRACE
CLOSED_HARD_BRACE
INTEGER
COMMA
IDENTIFIER size
COLON
INTEGER
CLOSED_PARENTHESIS
ASSIGNMENT
OPEN_CURLY_BRACE
IDENTIFIER i
COLON
INTEGER
SEMICOLON
FOR
OPEN_PARENTHESIS
IDENTIFIER i
ASSIGNMENT
INTEGER_LITERAL 0
SEMICOLON
IDENTIFIER i
LESS_THAN
IDENTIFIER size
SEMICOLON
IDENTIFIER i
POSTFIX_INCREMENT
CLOSED_PARENTHESIS
OPEN_CURLY_BRACE
PRINT
OPEN_PARENTHESIS
IDENTIFIER a
OPEN_HARD_BRACE
IDENTIFIER i
CLOSED_HARD_BRACE
CLOSED_PARENTHESIS
COMMA
ERROR




===[bad2.bminor Input]===
"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"

===[bad2.bminor Output]===
ERROR




===[bad3.bminor Input]===
// ''

puts: function void ( s: string );

main: function integer () = {
	puts('');
}

===[bad3.bminor Output]===
IDENTIFIER puts
COLON
FUNCTION
VOID
OPEN_PARENTHESIS
IDENTIFIER s
COLON
STRING
CLOSED_PARENTHESIS
SEMICOLON
IDENTIFIER main
COLON
FUNCTION
INTEGER
OPEN_PARENTHESIS
CLOSED_PARENTHESIS
ASSIGNMENT
OPEN_CURLY_BRACE
IDENTIFIER puts
OPEN_PARENTHESIS
ERROR




===[bad4.bminor Input]===
'hey! strings should be in double quotes!'

===[bad4.bminor Output]===
ERROR




===[bad5.bminor Input]===
// bad number

1234.1234

===[bad5.bminor Output]===
INTEGER_LITERAL 1234
ERROR




===[bad6.bminor Input]===
// bad string and comment

/* " not gonna work */ end string "

===[bad6.bminor Output]===
IDENTIFIER end
STRING
ERROR




===[bad7.bminor Input]===
// bad identifier

myvariable's: array [2] integer = {5,6};

===[bad7.bminor Output]===
IDENTIFIER myvariable
ERROR




===[bad8.bminor Input]===
// bad string

" not a valid string

===[bad8.bminor Output]===
ERROR




===[bad9.bminor Input]===
"

===[bad9.bminor Output]===
ERROR




=====HIDDEN TESTS=====
====Good Tests====
===[good1.bminor Input]===
// Easy comment
/* Easy comment */

===[good1.bminor Output]===




===[good10.bminor Input]===
// Modulus operator
15%3

// Exponentiation operator
2^6

// Negation
-value

// Postincrement and postdecrement
number++;

number--;

===[good10.bminor Output]===
INTEGER_LITERAL 15
MODULO
INTEGER_LITERAL 3
INTEGER_LITERAL 2
EXPONENT
INTEGER_LITERAL 6
SUBTRACT
IDENTIFIER value
IDENTIFIER number
POSTFIX_INCREMENT
SEMICOLON
IDENTIFIER number
POSTFIX_DECREMENT
SEMICOLON




===[good3.bminor Input]===
// Identifiers
CamelCase
lower_case
skiddo23
B4UFLY
i
x15


===[good3.bminor Output]===
IDENTIFIER CamelCase
IDENTIFIER lower_case
IDENTIFIER skiddo23
IDENTIFIER B4UFLY
IDENTIFIER i
IDENTIFIER x15




===[good5.bminor Input]===
// Various bits of punctuation
, : ; ( ) [ ] { }


===[good5.bminor Output]===
COMMA
COLON
SEMICOLON
OPEN_PARENTHESIS
CLOSED_PARENTHESIS
OPEN_HARD_BRACE
CLOSED_HARD_BRACE
OPEN_CURLY_BRACE
CLOSED_CURLY_BRACE




===[good6.bminor Input]===
// Complete function prototype
main: function integer ( argc: integer, argv: array [] string );


===[good6.bminor Output]===
IDENTIFIER main
COLON
FUNCTION
INTEGER
OPEN_PARENTHESIS
IDENTIFIER argc
COLON
INTEGER
COMMA
IDENTIFIER argv
COLON
ARRAY
OPEN_HARD_BRACE
CLOSED_HARD_BRACE
STRING
CLOSED_PARENTHESIS
SEMICOLON




===[good7.bminor Input]===
// Nested statements
if( x<15 ) {
    print "small";
} else {
    print "large!";
}


===[good7.bminor Output]===
IF
OPEN_PARENTHESIS
IDENTIFIER x
LESS_THAN
INTEGER_LITERAL 15
CLOSED_PARENTHESIS
OPEN_CURLY_BRACE
PRINT
STRING_LITERAL small
SEMICOLON
CLOSED_CURLY_BRACE
ELSE
OPEN_CURLY_BRACE
PRINT
STRING_LITERAL large!
SEMICOLON
CLOSED_CURLY_BRACE




===[good8.bminor Input]===
// Valid integers
0
1024
-512
+256


===[good8.bminor Output]===
INTEGER_LITERAL 0
INTEGER_LITERAL 1024
INTEGER_LITERAL -512
INTEGER_LITERAL +256




===[good2.bminor Input]===
////* Harder comment ***/
/******************/
/*
This one works too.
*/
/***************
Also a good comment.
****************/
// comment // comment // comment


===[good2.bminor Output]===




===[good4.bminor Input]===
// Equality Operators
== != <= < > >=
// Ternary Tokens
? :

===[good4.bminor Output]===
EQUAL
TOKEN_NEQ
LESS_THEN_OR_EQUAL_TO
LESS_THAN
GREATER_THAN
GREATER_THAN_OR_EQUAL_TO
QUESTION_MARK
COLON




===[good9.bminor Input]===
// Type Keywords
array
boolean
char
string
void
integer
auto

===[good9.bminor Output]===
ARRAY
BOOL
CHAR
STRING
VOID
INTEGER
AUTO




====Bad Tests====
===[bad1.bminor Input]===
"unmatched string""

===[bad1.bminor Output]===
STRING_LITERAL unmatched string
ERROR




===[bad10.bminor Input]===
#compilers // No hashtags in B-minor

===[bad10.bminor Output]===
ERROR




===[bad2.bminor Input]===
"unterminated \"


===[bad2.bminor Output]===
ERROR




===[bad3.bminor Input]===
never started"






===[bad3.bminor Output]===
IDENTIFIER never
IDENTIFIER started
ERROR




===[bad4.bminor Input]===
'character?' // Character too long.

===[bad4.bminor Output]===
ERROR




===[bad5.bminor Input]===
'' // Empty character not allowed.

===[bad5.bminor Output]===
ERROR




===[bad8.bminor Input]===
'' // Empty character not allowed.

===[bad8.bminor Output]===
ERROR




===[bad9.bminor Input]===
3.141592654 // No floating point

===[bad9.bminor Output]===
INTEGER_LITERAL 3
ERROR




===[bad6.bminor Input]===
~tilde // Invalid symbol

===[bad6.bminor Output]===
ERROR




===[bad7.bminor Input]===
/* Is this a valid comment */ @ */


===[bad7.bminor Output]===

scan error: @ is not a valid character



=====COMMON TESTS=====
====Good Tests====
===[good1.bminor Input]===
// just runs all basic tokens
//
/* comment */
array 
boolean 
char 
else 
false 
for 
function 
if 
integer 
print 
return 
string 
true
void
while
:
;
,
[
]
{
}
(
)
=
^
+
-
++
--
*
/
%
==
>=
<=
<
>
!=
a
ab
ab3
ab3a
12314
1
12
123
'A'
""
"a"
"aa"

===[good1.bminor Output]===
ARRAY
BOOL
CHAR
ELSE
FALSE
FOR
FUNCTION
IF
INTEGER
PRINT
RETURN
STRING
TRUE
VOID
WHILE
COLON
SEMICOLON
COMMA
OPEN_HARD_BRACE
CLOSED_HARD_BRACE
OPEN_CURLY_BRACE
CLOSED_CURLY_BRACE
OPEN_PARENTHESIS
CLOSED_PARENTHESIS
ASSIGNMENT
EXPONENT
ADD
SUBTRACT
POSTFIX_INCREMENT
POSTFIX_DECREMENT
MULTIPLY
DIVIDE
MODULO
EQUAL
GREATER_THAN_OR_EQUAL_TO
LESS_THEN_OR_EQUAL_TO
LESS_THAN
GREATER_THAN
TOKEN_NEQ
IDENTIFIER a
IDENTIFIER ab
IDENTIFIER ab3
IDENTIFIER ab3a
INTEGER_LITERAL 12314
INTEGER_LITERAL 1
INTEGER_LITERAL 12
INTEGER_LITERAL 123
CHARACTER_LITERAL A
STRING_LITERAL 
STRING_LITERAL a
STRING_LITERAL aa




===[good10.bminor Input]===
/* tests some more constructs in bminor */
z = -x; // unary negation
x^2; //exponantiotion
//simple test cases
x ^ 2
z != x % 2
z = 5 + 6;
z = 5 * 6;
z = 5 - 6;
z = 5 / 6;
q++;
z--;
z = 7 + 7 - z;


===[good10.bminor Output]===
IDENTIFIER z
ASSIGNMENT
SUBTRACT
IDENTIFIER x
SEMICOLON
IDENTIFIER x
EXPONENT
INTEGER_LITERAL 2
SEMICOLON
IDENTIFIER x
EXPONENT
INTEGER_LITERAL 2
IDENTIFIER z
TOKEN_NEQ
IDENTIFIER x
MODULO
INTEGER_LITERAL 2
IDENTIFIER z
ASSIGNMENT
INTEGER_LITERAL 5
ADD
INTEGER_LITERAL 6
SEMICOLON
IDENTIFIER z
ASSIGNMENT
INTEGER_LITERAL 5
MULTIPLY
INTEGER_LITERAL 6
SEMICOLON
IDENTIFIER z
ASSIGNMENT
INTEGER_LITERAL 5
SUBTRACT
INTEGER_LITERAL 6
SEMICOLON
IDENTIFIER z
ASSIGNMENT
INTEGER_LITERAL 5
DIVIDE
INTEGER_LITERAL 6
SEMICOLON
IDENTIFIER q
POSTFIX_INCREMENT
SEMICOLON
IDENTIFIER z
POSTFIX_DECREMENT
SEMICOLON
IDENTIFIER z
ASSIGNMENT
INTEGER_LITERAL 7
ADD
INTEGER_LITERAL 7
SUBTRACT
IDENTIFIER z
SEMICOLON




===[good11.bminor Input]===
// some more complicated corner cases
z = -(5 * 4);
z = 15 + 5 - 4*3/7;
z = x + (y * 5 - (4 + 20/v) - 15) % 6 + z; //long integer expr
z+++; // these will cause parsing errors
w---;


===[good11.bminor Output]===
IDENTIFIER z
ASSIGNMENT
SUBTRACT
OPEN_PARENTHESIS
INTEGER_LITERAL 5
MULTIPLY
INTEGER_LITERAL 4
CLOSED_PARENTHESIS
SEMICOLON
IDENTIFIER z
ASSIGNMENT
INTEGER_LITERAL 15
ADD
INTEGER_LITERAL 5
SUBTRACT
INTEGER_LITERAL 4
MULTIPLY
INTEGER_LITERAL 3
DIVIDE
INTEGER_LITERAL 7
SEMICOLON
IDENTIFIER z
ASSIGNMENT
IDENTIFIER x
ADD
OPEN_PARENTHESIS
IDENTIFIER y
MULTIPLY
INTEGER_LITERAL 5
SUBTRACT
OPEN_PARENTHESIS
INTEGER_LITERAL 4
ADD
INTEGER_LITERAL 20
DIVIDE
IDENTIFIER v
CLOSED_PARENTHESIS
SUBTRACT
INTEGER_LITERAL 15
CLOSED_PARENTHESIS
MODULO
INTEGER_LITERAL 6
ADD
IDENTIFIER z
SEMICOLON
IDENTIFIER z
POSTFIX_INCREMENT
ADD
SEMICOLON
IDENTIFIER w
POSTFIX_DECREMENT
SUBTRACT
SEMICOLON




===[good12.bminor Input]===
//tests the for/print keyword and while keyword
x:integer;
for(x = 0; x < 5; x++)
{
	print "counting: ", x;
}
a:integer = 0;
while(a > 0)
{
	a--;
}



===[good12.bminor Output]===
IDENTIFIER x
COLON
INTEGER
SEMICOLON
FOR
OPEN_PARENTHESIS
IDENTIFIER x
ASSIGNMENT
INTEGER_LITERAL 0
SEMICOLON
IDENTIFIER x
LESS_THAN
INTEGER_LITERAL 5
SEMICOLON
IDENTIFIER x
POSTFIX_INCREMENT
CLOSED_PARENTHESIS
OPEN_CURLY_BRACE
PRINT
STRING_LITERAL counting: 
COMMA
IDENTIFIER x
SEMICOLON
CLOSED_CURLY_BRACE
IDENTIFIER a
COLON
INTEGER
ASSIGNMENT
INTEGER_LITERAL 0
SEMICOLON
WHILE
OPEN_PARENTHESIS
IDENTIFIER a
GREATER_THAN
INTEGER_LITERAL 0
CLOSED_PARENTHESIS
OPEN_CURLY_BRACE
IDENTIFIER a
POSTFIX_DECREMENT
SEMICOLON
CLOSED_CURLY_BRACE




===[good13.bminor Input]===
//test some odd identifier names
ident55
ident55_
ident__55__
thisIsAReallyReallyLongIdentifierNameThatHasTonsOfLettersInIt = 7
variable_names_may_contain_underscores_
_variables_can_start_with_an_underscore_67
7minus5 

===[good13.bminor Output]===
IDENTIFIER ident55
IDENTIFIER ident55_
IDENTIFIER ident__55__
IDENTIFIER thisIsAReallyReallyLongIdentifierNameThatHasTonsOfLettersInIt
ASSIGNMENT
INTEGER_LITERAL 7
IDENTIFIER variable_names_may_contain_underscores_
IDENTIFIER _variables_can_start_with_an_underscore_67
INTEGER_LITERAL 7
IDENTIFIER minus5




===[good14.bminor Input]===
main: function integer ( argc: integer, argv: array [] string ) =
{
}
boolFunction: function boolean(intVar:integer) =
{
	return intVar > 5;
}
intFunction: function integer(integer n) =
{
	total:integer = 0;
	int count;
	for(count = 0; count < n+1; count++)
	{
		total = total + count;
	
}


===[good14.bminor Output]===
IDENTIFIER main
COLON
FUNCTION
INTEGER
OPEN_PARENTHESIS
IDENTIFIER argc
COLON
INTEGER
COMMA
IDENTIFIER argv
COLON
ARRAY
OPEN_HARD_BRACE
CLOSED_HARD_BRACE
STRING
CLOSED_PARENTHESIS
ASSIGNMENT
OPEN_CURLY_BRACE
CLOSED_CURLY_BRACE
IDENTIFIER boolFunction
COLON
FUNCTION
BOOL
OPEN_PARENTHESIS
IDENTIFIER intVar
COLON
INTEGER
CLOSED_PARENTHESIS
ASSIGNMENT
OPEN_CURLY_BRACE
RETURN
IDENTIFIER intVar
GREATER_THAN
INTEGER_LITERAL 5
SEMICOLON
CLOSED_CURLY_BRACE
IDENTIFIER intFunction
COLON
FUNCTION
INTEGER
OPEN_PARENTHESIS
INTEGER
IDENTIFIER n
CLOSED_PARENTHESIS
ASSIGNMENT
OPEN_CURLY_BRACE
IDENTIFIER total
COLON
INTEGER
ASSIGNMENT
INTEGER_LITERAL 0
SEMICOLON
IDENTIFIER int
IDENTIFIER count
SEMICOLON
FOR
OPEN_PARENTHESIS
IDENTIFIER count
ASSIGNMENT
INTEGER_LITERAL 0
SEMICOLON
IDENTIFIER count
LESS_THAN
IDENTIFIER n
INTEGER_LITERAL +1
SEMICOLON
IDENTIFIER count
POSTFIX_INCREMENT
CLOSED_PARENTHESIS
OPEN_CURLY_BRACE
IDENTIFIER total
ASSIGNMENT
IDENTIFIER total
ADD
IDENTIFIER count
SEMICOLON
CLOSED_CURLY_BRACE




===[good15.bminor Input]===
intFunction: function integer(intVar:integer, boolVar: boolean)
{
	if(boolVar)
	{
		intVar = intVar * 2;
	}
	return intVar;
}
// finds the largest value in the array
getLargest: function integer(intArrVar:array [] integer, int len) =
{
	largest:integer = 0;
	x:integer;
	for(x = 0; x < len; x++)
	{
		if(intArrVar[x] > largest)
		{
			largest = intArrVar[x];
		}
	}
	return largest;
		
}

main: function integer ( argc: integer, argv: array [] string ) =
{
	b:array [10] integer = {0,1,2,3,4,5};
	b[4] = 6;
	i:integer;
	z:integer = intFunction(i, true);
	print intArrFunction(v, z);
}

===[good15.bminor Output]===
IDENTIFIER intFunction
COLON
FUNCTION
INTEGER
OPEN_PARENTHESIS
IDENTIFIER intVar
COLON
INTEGER
COMMA
IDENTIFIER boolVar
COLON
BOOL
CLOSED_PARENTHESIS
OPEN_CURLY_BRACE
IF
OPEN_PARENTHESIS
IDENTIFIER boolVar
CLOSED_PARENTHESIS
OPEN_CURLY_BRACE
IDENTIFIER intVar
ASSIGNMENT
IDENTIFIER intVar
MULTIPLY
INTEGER_LITERAL 2
SEMICOLON
CLOSED_CURLY_BRACE
RETURN
IDENTIFIER intVar
SEMICOLON
CLOSED_CURLY_BRACE
IDENTIFIER getLargest
COLON
FUNCTION
INTEGER
OPEN_PARENTHESIS
IDENTIFIER intArrVar
COLON
ARRAY
OPEN_HARD_BRACE
CLOSED_HARD_BRACE
INTEGER
COMMA
IDENTIFIER int
IDENTIFIER len
CLOSED_PARENTHESIS
ASSIGNMENT
OPEN_CURLY_BRACE
IDENTIFIER largest
COLON
INTEGER
ASSIGNMENT
INTEGER_LITERAL 0
SEMICOLON
IDENTIFIER x
COLON
INTEGER
SEMICOLON
FOR
OPEN_PARENTHESIS
IDENTIFIER x
ASSIGNMENT
INTEGER_LITERAL 0
SEMICOLON
IDENTIFIER x
LESS_THAN
IDENTIFIER len
SEMICOLON
IDENTIFIER x
POSTFIX_INCREMENT
CLOSED_PARENTHESIS
OPEN_CURLY_BRACE
IF
OPEN_PARENTHESIS
IDENTIFIER intArrVar
OPEN_HARD_BRACE
IDENTIFIER x
CLOSED_HARD_BRACE
GREATER_THAN
IDENTIFIER largest
CLOSED_PARENTHESIS
OPEN_CURLY_BRACE
IDENTIFIER largest
ASSIGNMENT
IDENTIFIER intArrVar
OPEN_HARD_BRACE
IDENTIFIER x
CLOSED_HARD_BRACE
SEMICOLON
CLOSED_CURLY_BRACE
CLOSED_CURLY_BRACE
RETURN
IDENTIFIER largest
SEMICOLON
CLOSED_CURLY_BRACE
IDENTIFIER main
COLON
FUNCTION
INTEGER
OPEN_PARENTHESIS
IDENTIFIER argc
COLON
INTEGER
COMMA
IDENTIFIER argv
COLON
ARRAY
OPEN_HARD_BRACE
CLOSED_HARD_BRACE
STRING
CLOSED_PARENTHESIS
ASSIGNMENT
OPEN_CURLY_BRACE
IDENTIFIER b
COLON
ARRAY
OPEN_HARD_BRACE
INTEGER_LITERAL 10
CLOSED_HARD_BRACE
INTEGER
ASSIGNMENT
OPEN_CURLY_BRACE
INTEGER_LITERAL 0
COMMA
INTEGER_LITERAL 1
COMMA
INTEGER_LITERAL 2
COMMA
INTEGER_LITERAL 3
COMMA
INTEGER_LITERAL 4
COMMA
INTEGER_LITERAL 5
CLOSED_CURLY_BRACE
SEMICOLON
IDENTIFIER b
OPEN_HARD_BRACE
INTEGER_LITERAL 4
CLOSED_HARD_BRACE
ASSIGNMENT
INTEGER_LITERAL 6
SEMICOLON
IDENTIFIER i
COLON
INTEGER
SEMICOLON
IDENTIFIER z
COLON
INTEGER
ASSIGNMENT
IDENTIFIER intFunction
OPEN_PARENTHESIS
IDENTIFIER i
COMMA
TRUE
CLOSED_PARENTHESIS
SEMICOLON
PRINT
IDENTIFIER intArrFunction
OPEN_PARENTHESIS
IDENTIFIER v
COMMA
IDENTIFIER z
CLOSED_PARENTHESIS
SEMICOLON
CLOSED_CURLY_BRACE




===[good2.bminor Input]===
// basic data types
number: integer;
number = 56;
number = -56;
number = +56;
number = 0005006;
number = +0005006;
number = -000050006;









===[good2.bminor Output]===
IDENTIFIER number
COLON
INTEGER
SEMICOLON
IDENTIFIER number
ASSIGNMENT
INTEGER_LITERAL 56
SEMICOLON
IDENTIFIER number
ASSIGNMENT
INTEGER_LITERAL -56
SEMICOLON
IDENTIFIER number
ASSIGNMENT
INTEGER_LITERAL +56
SEMICOLON
IDENTIFIER number
ASSIGNMENT
INTEGER_LITERAL 0005006
SEMICOLON
IDENTIFIER number
ASSIGNMENT
INTEGER_LITERAL +0005006
SEMICOLON
IDENTIFIER number
ASSIGNMENT
INTEGER_LITERAL -000050006
SEMICOLON




===[good3.bminor Input]===
//test some boolean types
bool:boolean = true;
bool:boolean = false;
bool = 5 > 4;


===[good3.bminor Output]===
IDENTIFIER bool
COLON
BOOL
ASSIGNMENT
TRUE
SEMICOLON
IDENTIFIER bool
COLON
BOOL
ASSIGNMENT
FALSE
SEMICOLON
IDENTIFIER bool
ASSIGNMENT
INTEGER_LITERAL 5
GREATER_THAN
INTEGER_LITERAL 4
SEMICOLON




===[good4.bminor Input]===
// basic data types


character:	 	char = 'c';
character: char = '\n';
character:	char = '\0';
character = '\6';
character = '\c'
character = '\t'


===[good4.bminor Output]===
IDENTIFIER character
COLON
CHAR
ASSIGNMENT
CHARACTER_LITERAL c
SEMICOLON
IDENTIFIER character
COLON
CHAR
ASSIGNMENT
CHARACTER_LITERAL 

SEMICOLON
IDENTIFIER character
COLON
CHAR
ASSIGNMENT
CHARACTER_LITERAL 0
SEMICOLON
IDENTIFIER character
ASSIGNMENT
CHARACTER_LITERAL 6
SEMICOLON
IDENTIFIER character
ASSIGNMENT
CHARACTER_LITERAL c
IDENTIFIER character
ASSIGNMENT
CHARACTER_LITERAL t




===[good5.bminor Input]===
"This is a string"
"Notre \n Dame"
" "
" string with numbers 3213"
"String with @@ works in the program"
""

===[good5.bminor Output]===
STRING_LITERAL This is a string
STRING_LITERAL Notre 
 Dame
STRING_LITERAL  
STRING_LITERAL  string with numbers 3213
STRING_LITERAL String with @@ works in the program
STRING_LITERAL 




===[good6.bminor Input]===
// strings
str:string = "";

str:string = "we can write an escaped backslash \\";
" \"this is a unique test case \" ";
" \n \t \0"
"\e \r \y"
str:string = "single qoute ' or \' ";
str:string = " double qoute \" ";


===[good6.bminor Output]===
IDENTIFIER str
COLON
STRING
ASSIGNMENT
STRING_LITERAL 
SEMICOLON
IDENTIFIER str
COLON
STRING
ASSIGNMENT
STRING_LITERAL we can write an escaped backslash 
SEMICOLON
STRING_LITERAL  "this is a unique test case " sh 
SEMICOLON
STRING_LITERAL  
 t 0
STRING_LITERAL e r y
IDENTIFIER str
COLON
STRING
ASSIGNMENT
STRING_LITERAL single qoute ' or ' 
SEMICOLON
IDENTIFIER str
COLON
STRING
ASSIGNMENT
STRING_LITERAL  double qoute " r '
SEMICOLON




===[good7.bminor Input]===
// strings
str:string = "";

str:string = "hello this is a string!";
str:string = "hello this is \1 a string!";

str:string = "11234567891123456789112345678911234567891123456789112345678911234567891123456789112345678911234567891123456789112345678911234567891123456789112345678911234567"// less then 160 characters 



===[good7.bminor Output]===
IDENTIFIER str
COLON
STRING
ASSIGNMENT
STRING_LITERAL 
SEMICOLON
IDENTIFIER str
COLON
STRING
ASSIGNMENT
STRING_LITERAL hello this is a string!
SEMICOLON
IDENTIFIER str
COLON
STRING
ASSIGNMENT
STRING_LITERAL hello this is 1 a string!
SEMICOLON
IDENTIFIER str
COLON
STRING
ASSIGNMENT
STRING_LITERAL 11234567891123456789112345678911234567891123456789112345678911234567891123456789112345678911234567891123456789112345678911234567891123456789112345678911234567




===[good8.bminor Input]===
//test arrays
f:array [5]integer = { 1, 2, 3, 4, 5};
f:array[5]char = {'a', 'b', 'c', 'd', 'e'};
f:array[5] boolean = {false, false, true, true, true};
f:array [] 	string = {"this", "i", "s", "a,", "test", "."};

===[good8.bminor Output]===
IDENTIFIER f
COLON
ARRAY
OPEN_HARD_BRACE
INTEGER_LITERAL 5
CLOSED_HARD_BRACE
INTEGER
ASSIGNMENT
OPEN_CURLY_BRACE
INTEGER_LITERAL 1
COMMA
INTEGER_LITERAL 2
COMMA
INTEGER_LITERAL 3
COMMA
INTEGER_LITERAL 4
COMMA
INTEGER_LITERAL 5
CLOSED_CURLY_BRACE
SEMICOLON
IDENTIFIER f
COLON
ARRAY
OPEN_HARD_BRACE
INTEGER_LITERAL 5
CLOSED_HARD_BRACE
CHAR
ASSIGNMENT
OPEN_CURLY_BRACE
CHARACTER_LITERAL a
COMMA
CHARACTER_LITERAL b
COMMA
CHARACTER_LITERAL c
COMMA
CHARACTER_LITERAL d
COMMA
CHARACTER_LITERAL e
CLOSED_CURLY_BRACE
SEMICOLON
IDENTIFIER f
COLON
ARRAY
OPEN_HARD_BRACE
INTEGER_LITERAL 5
CLOSED_HARD_BRACE
BOOL
ASSIGNMENT
OPEN_CURLY_BRACE
FALSE
COMMA
FALSE
COMMA
TRUE
COMMA
TRUE
COMMA
TRUE
CLOSED_CURLY_BRACE
SEMICOLON
IDENTIFIER f
COLON
ARRAY
OPEN_HARD_BRACE
CLOSED_HARD_BRACE
STRING
ASSIGNMENT
OPEN_CURLY_BRACE
STRING_LITERAL this
COMMA
STRING_LITERAL i
COMMA
STRING_LITERAL s
COMMA
STRING_LITERAL a,
COMMA
STRING_LITERAL test
COMMA
STRING_LITERAL .
CLOSED_CURLY_BRACE
SEMICOLON




===[good9.bminor Input]===
// test comparotors and boolean logic
if ( a >= 5 )
{
	print "a >= 5";
}
if( a > 5 )
{
	print "a > 5";
}
if( a <= 5 )
{
	print "a <= 5";
}
if( a < 5 )
{
	print "a < 5";
}
if( a == 5 )
{
	print "a == 5";
}
if( a != 5 )
{
	print "a != 5";
}
a = 5; // test assigment
if (a || b)
{
	print " a || b is true";
}
if (a && b)
{
	print " a && b is true";
}

===[good9.bminor Output]===
IF
OPEN_PARENTHESIS
IDENTIFIER a
GREATER_THAN_OR_EQUAL_TO
INTEGER_LITERAL 5
CLOSED_PARENTHESIS
OPEN_CURLY_BRACE
PRINT
STRING_LITERAL a >= 5
SEMICOLON
CLOSED_CURLY_BRACE
IF
OPEN_PARENTHESIS
IDENTIFIER a
GREATER_THAN
INTEGER_LITERAL 5
CLOSED_PARENTHESIS
OPEN_CURLY_BRACE
PRINT
STRING_LITERAL a > 5
SEMICOLON
CLOSED_CURLY_BRACE
IF
OPEN_PARENTHESIS
IDENTIFIER a
LESS_THEN_OR_EQUAL_TO
INTEGER_LITERAL 5
CLOSED_PARENTHESIS
OPEN_CURLY_BRACE
PRINT
STRING_LITERAL a <= 5
SEMICOLON
CLOSED_CURLY_BRACE
IF
OPEN_PARENTHESIS
IDENTIFIER a
LESS_THAN
INTEGER_LITERAL 5
CLOSED_PARENTHESIS
OPEN_CURLY_BRACE
PRINT
STRING_LITERAL a < 5
SEMICOLON
CLOSED_CURLY_BRACE
IF
OPEN_PARENTHESIS
IDENTIFIER a
EQUAL
INTEGER_LITERAL 5
CLOSED_PARENTHESIS
OPEN_CURLY_BRACE
PRINT
STRING_LITERAL a == 5
SEMICOLON
CLOSED_CURLY_BRACE
IF
OPEN_PARENTHESIS
IDENTIFIER a
TOKEN_NEQ
INTEGER_LITERAL 5
CLOSED_PARENTHESIS
OPEN_CURLY_BRACE
PRINT
STRING_LITERAL a != 5
SEMICOLON
CLOSED_CURLY_BRACE
IDENTIFIER a
ASSIGNMENT
INTEGER_LITERAL 5
SEMICOLON
IF
OPEN_PARENTHESIS
IDENTIFIER a
OR
IDENTIFIER b
CLOSED_PARENTHESIS
OPEN_CURLY_BRACE
PRINT
STRING_LITERAL  a || b is true
SEMICOLON
CLOSED_CURLY_BRACE
IF
OPEN_PARENTHESIS
IDENTIFIER a
AND
IDENTIFIER b
CLOSED_PARENTHESIS
OPEN_CURLY_BRACE
PRINT
STRING_LITERAL  a && b is true
SEMICOLON
CLOSED_CURLY_BRACE




====Bad Tests====
===[bad1.bminor Input]===
@
#
&
|
\

===[bad1.bminor Output]===

scan error: @ is not a valid character



===[bad10.bminor Input]===
// invalid character
'\'

===[bad10.bminor Output]===
ERROR




===[bad11.bminor Input]===
/*
A string should not contain a literal newline,
but use backslash-n instead.
*/

"invalid

string"

===[bad11.bminor Output]===
ERROR




===[bad12.bminor Input]===
'ca'

===[bad12.bminor Output]===
ERROR




===[bad13.bminor Input]===
''

===[bad13.bminor Output]===
ERROR




===[bad14.bminor Input]===
'\ac'

===[bad14.bminor Output]===
ERROR




===[bad15.bminor Input]===
'

===[bad15.bminor Output]===
ERROR




===[bad2.bminor Input]===
// unmatched comment throws error 
/* This is a comment.








===[bad2.bminor Output]===
DIVIDE
MULTIPLY
IDENTIFIER This
IDENTIFIER is
IDENTIFIER a
IDENTIFIER comment
ERROR




===[bad3.bminor Input]===
// basic data types
" the quote is unmatched







===[bad3.bminor Output]===
ERROR




===[bad4.bminor Input]===
// doesn't support floating point
50006.0050;

===[bad4.bminor Output]===
INTEGER_LITERAL 50006
ERROR




===[bad5.bminor Input]===
// test comparotors and boolean logic
if (a | b)
{
	print " a || b is true";
}
if (a & b)// must had 2 &&
{
	print " a || b is true";
}

===[bad5.bminor Output]===
IF
OPEN_PARENTHESIS
IDENTIFIER a
ERROR




===[bad6.bminor Input]===

"""


===[bad6.bminor Output]===
STRING_LITERAL 
ERROR




===[bad7.bminor Input]===
"012345678901234567890101234567890123456789010123456789012345678901012345678901234567890101234567890123456789010123456789012345678901012345678901234567890101234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890"


===[bad7.bminor Output]===
ERROR




===[bad8.bminor Input]===
$minus

===[bad8.bminor Output]===
ERROR




===[bad9.bminor Input]===
minus#44

===[bad9.bminor Output]===
IDENTIFIER minus
ERROR




